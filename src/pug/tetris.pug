extends /layout/_application

prepend Config
  - title = 'TETRIS with ES2015'

block content
  section.bg-red
    span.background.dark(style="background-image:url('https://source.unsplash.com/R1J6Z1cnJZc/1600x800')")
    // .wrap = container (width: 90%)
    .wrap.aligncenter
      h1
        strong TETRIS with ES2015
      h5.text-symbols ***
    // .end .wrap
  section
    // .wrap = container (width: 90%)
    .wrap.size-70
      h2
        strong Agenda
      hr
      ol.text-cols
        li トレーニング概要
        li 自己紹介
        li 開発環境構築
        li About Canavs
        li 実装要件
        li Build Game Logic
  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    // .wrap = container (width: 90%)
    .wrap.aligncenter.fadeInUp
      h3
        strong トレーニング概要
    // .end .wrap
  section.slide-top
    // .wrap = container (width: 90%)
    .wrap
      div
        h1 JavascriptでTETRISをつくろう
        h4: a(href="https://github.com/atsutopia/tetris/tree/v-0.0.1-template" target="_blank") Demo
  section.fullscreen
    span.background.dark(style="background-image:url('./images/cover/profile.png'); width: 60%; height: 120%; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: .4;")
    h2(style="position: relative; font-weight: bold;") WHAT I'M ABOUT
    p(style="position: relative; font-weight: bold;")
      | 株式会社TRUNK TL Kawasaki Atsushi<br>
      | 2013年じげんグループHRメディア事業のPMやバックエンドを担当。<br>
      | 新規事業立ち上げの経験を経てエンジニアリングユニットのマネージャーに従事。<br>
      |
      | 2015年に株式会社カヤックへ入社。<br>
      | クライアントワークや自社サービス(Lobi)のフロントエンド、バックエンドおよびインフラ設計、構築、運用を担当。<br>

  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    // .wrap = container (width: 90%)
    .wrap.aligncenter.fadeInUp
      h3
        strong 開発環境構築
    // .end .wrap

  section.slide-top
    h3 Parcel
    p
      | Repository
      h4: a(href="https://github.com/atsutopia/tetris/tree/v-0.0.1-template" target="_blank") https://github.com/atsutopia/tetris/tree/v-0.0.1-template
    p
      | About Parcel
      h4: a(href="https://parceljs.org/" target="_blank") https://parceljs.org/
  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    .wrap.aligncenter.fadeInUp
      h3
        strong About Canavs
  section.slide-top
    .wrap
      div
        h2 Canvas API
        p
          | HTML5 で導入された canvas 要素は、JavaScript によるスクリプティングによって図形などを描画するために使用します。例えば、グラフを描く、写真を合成する、アニメーションを作成する、動画のリアルタイム加工やレンダリングに用いる事が出来ます。
        a(href="https://developer.mozilla.org/ja/docs/Web/HTML/Canvas" target="_blank") https://developer.mozilla.org/ja/docs/Web/HTML/Canvas
    // .end .wrap

  section.slide-top
    .wrap
      div
        h2 Canvas API
        p
          | 図形の作成 <br>
          a(href="http://cheatsheetworld.com/programming/html5-canvas-cheat-sheet/" target="_blank") http://cheatsheetworld.com/programming/html5-canvas-cheat-sheet/
          ol
            li 色を変えてみよう
            li 座標を変えてみよう
            li 大きさを変えてみよう
        <p data-height="465" data-width="640" data-theme-id="0" data-slug-hash="dqGLLX" data-default-tab="js,result" data-user="pickrusu" data-pen-title="Canvas API" class="codepen">See the Pen <a href="https://codepen.io/pickrusu/pen/dqGLLX/">Canvas API</a> by pickrusu (<a href="https://codepen.io/pickrusu">@pickrusu</a>) on <a href="https://codepen.io">CodePen</a>.</p>

        p
          | Ref:
          a(href="https://simon.html5.org/dump/html5-canvas-cheat-sheet.html") Canvas Cheat Sheet

  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    .wrap.aligncenter.fadeInUp
      h3
        strong 実装要件

  section.slide-top
    // .wrap = container (width: 90%)
    .wrap
      div
        h3 極力シンプルなテトリスの実装を目指す
        a(href="https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%88%E3%83%AA%E3%82%B9") テトリス ルール参照
      p
        ol
          li 4つの正方形で構成されるテトリミノ7種がランダムに落下してくる
          li テトリミノがフィールド最下段、または他のテトリミノの上に着地するか引っかかると、そのテトリミノはブロックとしてフィールドに固定される。そして新しいテトリミノがフィールド上方に出現する。
          li 上左右下キーカーソルでのテトリミノが移動可能。上キーカーソルで時計回りにテトリミノを回転
          li 行がすべてブロックで埋め尽くされると、その段が消滅する
          li テトリミノによって新しいテトリミノがフィールド上方に出現不可になった時点でゲームオーバー

  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    .wrap.aligncenter.fadeInUp
      h3
        strong Build Step

  section.slide-top
    // .wrap = container (width: 90%)
    .wrap
      div
        h3 実装ステップ
      p
        ol
          li Canvasを利用してステージを描画
          li 4つの正方形で構成されるテトリミノをランダムに出現
          li テトリミノの落下アニメーション
          li 衝突判定
          li キーカーソルでテトリミノの操作
          li 行の削除処理

  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    .wrap.aligncenter.fadeInUp
      h3
        strong Step.1 Canvasを利用してステージを描画

  section.slide-top
    .wrap
      div
        h3 2次元配列でテトリスのステージを定義してcanvasに描画する
      p
        pre
          | import _ from "lodash"
          |
          | const BLOCK_SIZE = 24
          | const BLOCK_ROWS = 22
          | const BLOCK_COLS = 12
          |
          | const SCREEN_WIDTH = BLOCK_SIZE * BLOCK_COLS
          | const SCREEN_HEIGHT = BLOCK_SIZE * BLOCK_ROWS
          |
          | const NON_BLOCK = 0
          | const WALL = 9
          |
          | const BACK_COLOR = "#f5f5f5"
          | const WALL_COLOR = "#000000"
          |
          | const STAGE = [
          |   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],
          |   [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
          |   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          |   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          |   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          | ]
          |
          |
          |
          |
          | export default class Tetris {
          |   constructor (canvas) {
          |     canvas.width = SCREEN_WIDTH
          |     canvas.height = SCREEN_HEIGHT
          |     this.cxt = canvas.getContext("2d")
          |
          |     this.stage = _.cloneDeep(STAGE)
          |     this.draw()
          |   }
          |
          |   draw () {
          |     for (let row = 0; row < BLOCK_ROWS; row++) {
          |       for (let col = 0; col < BLOCK_COLS; col++) {
          |         switch(this.stage[row][col]){
          |           case NON_BLOCK:
          |             this.cxt.fillStyle = BACK_COLOR
          |             break
          |         }
          |         this.cxt.fillRect(col * BLOCK_SIZE, row * BLOCK_SIZE, BLOCK_SIZE -1, BLOCK_SIZE - 1)
          |       }
          |     }
          |   }
          | }

  section.slide-top
    .wrap
      div
        h3 セルがWALLのときのカラーも設定しましょう
      p
        h4 完成図
        img(src="images/tetris/wall.png")

  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    .wrap.aligncenter.fadeInUp
      h3
        strong Step.2 4つの正方形で構成されるテトリミノをランダムに出現

  section.slide-top
    .wrap
      div
        h3 ランダムにブロックを取得して値をセット
      pre
        |
        |
        | const NON_BLOCK = 0
        | const NORMAL_BLOCK = 1
        | const WALL = 9
        |
        |
        | const BLOCK_COLOR = "#00ffff"
        | const BACK_COLOR = "#f5f5f5"
        | const WALL_COLOR = "#000000"
        |
        | const	BLOCKS = [
        |   [
        |     [0, 0, 0, 0],
        |     [0, 1, 1, 0],
        |     [0, 1, 1, 0],
        |     [0, 0, 0, 0],
        |  ],
        |  [
        |    [0, 0, 1, 0],
        |    [0, 0, 1, 0],
        |    [0, 0, 1, 0],
        |    [0, 0, 1, 0],
        |  ],
        | ]
        |
        | export default class Tetris {
        |   constructor (canvas) {
        |     ...省略
        |     this.x = 0
        |     this.y = 0
        |     this.beforeX = 0
        |     this.beforeY = 0
        |     this.block = []
        |
        |     this.createBlock()
        |     this.updateBlock()
        |     this.draw()
        |   }
        |
        |   // ランダムにブロックを取得
        |   // 座標の初期値をセット
        |   createBlock () {
        |   }
        |
        |   // this.stageへblockの値を反映
        |   updateBlock () {
        |   }
        | }
  section.slide-top
    .wrap
      h4 完成図
      img(src="images/tetris/step2.gif")

  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    .wrap.aligncenter.fadeInUp
      h3
        strong Step.3 テトリミノの落下アニメーション

  section.slide-top
    .wrap
      div
        h3 requestAnimationFrameを利用してdrawを定期実行

      pre
        | const speed = 500
        | let lastUpdate = 0
        | // 定期実行処理
        | this.ticker = (timestamp) => {
        |   this.beforeX = this.x
        |   this.beforeY = this.y

        |   const diff = timestamp - lastUpdate
        |   // 500msごとにy座標をずらして落下させる
        |   if (diff > speed) {
        |     lastUpdate = timestamp
        |     this.y++
        |   }

        |   requestAnimationFrame(this.ticker)
        | }
        | requestAnimationFrame(this.ticker)

  section.slide-top
    .wrap
      h4 実行例
      img(src="images/tetris/step3-1.gif")

  section.slide-top
    .wrap
      div
        h3 残像が残ってしまうので更新時にブロックを消す
      pre
        | const speed = 500
        | let lastUpdate = 0
        | // 定期実行処理
        | this.ticker = (timestamp) => {
        |   this.beforeX = this.x
        |   this.beforeY = this.y
        |
        |   const diff = timestamp - lastUpdate
        |   // 500msごとにy座標をずらして落下させる
        |   if (diff > speed) {
        |     lastUpdate = timestamp
        |     this.clearBlock()
        |     this.y++
        |   }
        |
        |   requestAnimationFrame(this.ticker)
        | }
        | requestAnimationFrame(this.ticker)
        |
        |
        | // ブロックを0に戻す
        | clearBlock () {
        | }
        |
  section.slide-top
    .wrap
      h4 完成図
      img(src="images/tetris/step3-2.gif")

  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    .wrap.aligncenter.fadeInUp
      h3
        strong 衝突判定

  section.slide-top
    .wrap
      h4 ステージの座標とブロックの座標を取得し、両方ゼロじゃない場合は衝突と判定

      pre
        | const speed = 500
        | let lastUpdate = 0
        | // 定期実行処理
        | this.ticker = (timestamp) => {
        |   this.beforeX = this.x
        |   this.beforeY = this.y
        |
        |   const diff = timestamp - lastUpdate
        |   // 500msごとにy座標をずらして落下させる
        |   if (diff > speed) {
        |     lastUpdate = timestamp
        |     this.clearBlock()
        |     this.y++
        |
        |     // 衝突の場合は座標を戻して、新しくブロックを作成
        |     if (this.isHit()) {
        |       this.y = this.beforeY
        |       this.createBlock()
        |     }
        |     this.updateBlock()
        |   }
        |
        |   requestAnimationFrame(this.ticker)
        | }
        | requestAnimationFrame(this.ticker)
        |
        |
        | // 衝突判定
        | isHit () {
        | }

  section.slide-top
    .wrap
      h4 実行例
      img(src="images/tetris/step4-1.gif")

  section.slide-top
    .wrap
      h4 衝突したブロックを保持

      pre
        | const NON_BLOCK = 0
        | const NORMAL_BLOCK = 1
        | const WALL = 9
        | const LOCK_BLOCK = 2
        |
        | const BLOCK_COLOR = "#00ffff"
        | const BACK_COLOR = "#f5f5f5"
        | const WALL_COLOR = "#000000"
        | const LOCK_COLOR = "#c0c0c0"
        |
        | export default class Tetris {
        |   constructor (canvas) {
        |     this.ticker = (timestamp) => {
        |       ...省略
        |       if (diff > speed) {
        |         lastUpdate = timestamp
        |
        |         this.clearBlock()
        |         this.y++
        |         if (this.isHit()) {
        |           this.y = this.beforeY
        |           this.lockBlock()
        |           this.createBlock()
        |         }
        |         this.updateBlock()
        |       }
        |       this.draw()
        |
        |       requestAnimationFrame(this.ticker)
        |     }
        |   }
        |
        |   // LOCK_BLOCKの値を座標に代入
        |   lockBlock () {
        |   }
        | }

  section.slide-top
    .wrap
      h4 完成図
      img(src="images/tetris/step4-2.gif")

  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    .wrap.aligncenter.fadeInUp
      h3
        strong Step.5 キーカーソルでテトリミノの操作

  section.slide-top
    .wrap
      div
        h3 左右/下の移動
      p
      pre
        | const KEY_LEFT = 37
        | const KEY_UP = 38
        | const KEY_RIGHT = 39
        | const KEY_DOWN = 40
        |
        |
        | export default class Tetris {
        |   constructor (canvas) {
        |     window.addEventListener("keydown", (evt) => {
        |       this.keyHandler(evt)
        |     })
        |   }
        |
        |   keyHandler (e) {
        |     this.clearBlock()
        |     this.beforeX = this.x
        |     this.beforeY = this.y
        |
        |     // キーを入力したときに座標を移動
        |     switch (e.keyCode) {
        |     }
        |
        |     if (this.isHit()) {
        |       this.x = this.beforeX
        |       this.y = this.beforeY
        |     }
        |
        |     this.updateBlock()
        |   }
        | }

  section.slide-top
    .wrap
      div
        h3 上カーソルで回転処理
      p
        pre

          | rotateBlock () {
          |   this.clearBlock()
          |
          |   const beforeBlock = _.cloneDeep(this.block)
          |   const copy = new Array(this.block)
          |   // 回転処理
          |
          |   this.block = copy
          |
          |   if (this.isHit()) {
          |     this.block = beforeBlock
          |   }
          | }

  section.slide-top
    .wrap
      h4 完成図
      img(src="images/tetris/step5-1.gif")

  section.bg-green
    span.background.dark(style="background-image:url('https://images.unsplash.com/photo-1535219241072-7d3c28a49a5c')")
    .wrap.aligncenter.fadeInUp
      h3
        strong 行の削除処理 / ゲームオーバー処理
  section.slide-top
    .wrap
      h4 isHitに入ってきたときに行の削除チェック
      pre
        | export default class Tetris {
        |   constructor (canvas) {
        |     this.ticker = (timestamp) => {
        |       ...省略
        |       if (diff > speed) {
        |         lastUpdate = timestamp
        |
        |         this.clearBlock()
        |         this.y++
        |         if (this.isHit()) {
        |           this.y = this.beforeY
        |           this.lockBlock()
        |           this.deleteLine()
        |           this.createBlock()
        |         }
        |         this.updateBlock()
        |       }
        |       this.draw()
        |
        |       requestAnimationFrame(this.ticker)
        |     }
        |   }
        |
        |   // 行の削除処理
        |   deleteLine () {
        |   }
        | }

  section.slide-top
    .wrap
      h4 実行例
      img(src="images/tetris/step6-1.gif")

  section.slide-top
    .wrap
      h4 createBlockした瞬間にisHitした場合はゲームオーバー
      pre
        | const GAMEOVER = 0
        |
        | export default class Tetris {
        |   constructor (canvas) {
        |     this.ticker = (timestamp) => {
        |       if (this.mode === GAMEOVER) return
        |       ...省略
        |     }
        |   }
        | }
        |
        | createBlock () {
        |   ...省略
        |
        |   if (this.isHit()) {
        |     this.mode = GAMEOVER
        |   }
        | }
  section.slide-top
    .wrap
      h4 ブロックの種類を追加
      pre
        | const	BLOCKS = [
        |  [
        |     [0, 0, 0, 0],
        |     [0, 1, 1, 0],
        |     [0, 1, 1, 0],
        |     [0, 0, 0, 0],
        |  ],
        |  [
        |    [0, 0, 1, 0],
        |    [0, 0, 1, 0],
        |    [0, 0, 1, 0],
        |    [0, 0, 1, 0],
        |  ],
        |  [
        |    [0, 0, 1, 0],
        |    [0, 1, 1, 0],
        |    [0, 1, 0, 0],
        |    [0, 0, 0, 0],
        |  ],
        |  [
        |    [0, 1, 0, 0],
        |    [0, 1, 1, 0],
        |    [0, 0, 1, 0],
        |    [0, 0, 0, 0],
        |  ],
        |  [
        |    [0, 0, 0, 0],
        |    [0, 1, 1, 0],
        |    [0, 1, 0, 0],
        |    [0, 1, 0, 0],
        |  ],
        |  [
        |    [0, 0, 0, 0],
        |    [0, 1, 1, 0],
        |    [0, 0, 1, 0],
        |    [0, 0, 1, 0],
        |  ],
        |  [
        |    [0, 0, 0, 0],
        |    [0, 1, 0, 0],
        |    [1, 1, 1, 0],
        |    [0, 0, 0, 0],
        |  ]
        | ]
  section.slide-top
    .wrap
      h4 完成！
      img(src="images/tetris/step7.gif")



  <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
